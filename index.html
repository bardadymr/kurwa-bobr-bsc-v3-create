// Ниже представлен код для обновления фронтенд-части приложения
// для интеграции с нашим новым бэкендом API.
// Добавьте эти функции в script.js

// URL бэкенда (будет заменен на URL ngrok)
const API_BASE_URL = 'http://localhost:3000/api';

// Функция для загрузки изображения в IPFS через бэкенд
async function uploadImageToIPFS(imageFile) {
    try {
        const formData = new FormData();
        formData.append('image', imageFile);
        
        const response = await fetch(`${API_BASE_URL}/upload-image`, {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка при загрузке изображения');
        }
        
        const data = await response.json();
        return data.ipfsUrl; // URL в формате ipfs://hash
    } catch (error) {
        console.error('Ошибка при загрузке изображения в IPFS:', error);
        throw error;
    }
}

// Функция для расчета начальной цены токена
async function calculateInitialPrice(maxRaising, totalSupply, maxOffers) {
    try {
        const response = await fetch(`${API_BASE_URL}/calc-initial-price`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                maxRaising,
                totalSupply,
                maxOffers
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка при расчете начальной цены');
        }
        
        const data = await response.json();
        return data.initialPrice;
    } catch (error) {
        console.error('Ошибка при расчете начальной цены:', error);
        throw error;
    }
}

// Функция для получения подписи для создания токена
async function getTokenCreationSignature(tokenData) {
    try {
        const response = await fetch(`${API_BASE_URL}/generate-signature`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify(tokenData)
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Ошибка при получении подписи');
        }
        
        const data = await response.json();
        return {
            data: data.data,
            signature: data.signature
        };
    } catch (error) {
        console.error('Ошибка при получении подписи для создания токена:', error);
        throw error;
    }
}

// Обновите функцию handleCreateToken, чтобы использовать наш бэкенд API
async function handleCreateToken() {
    if (!validateForm()) {
        return;
    }
    
    // Показать состояние загрузки
    createTokenBtn.disabled = true;
    submitSpinner.style.display = 'inline-block';
    createTokenBtn.textContent = ' Создание токена...';
    
    try {
        // Подключение к кошельку
        const account = await connectWallet();
        if (!account) {
            // Сбросить состояние кнопки
            createTokenBtn.disabled = false;
            submitSpinner.style.display = 'none';
            createTokenBtn.textContent = 'Подключить кошелек и создать токен';
            return;
        }
        
        // 1. Загрузка изображения в IPFS
        showStatusMessage('Загрузка изображения...', 'info');
        const imageUrl = await uploadImageToIPFS(tokenImage);
        
        // 2. Подготовка данных токена
        const totalSupplyValue = totalSupplyInput.value;
        const maxOffersValue = maxOffersInput.value;
        const maxRaisingValue = maxRaisingInput.value;
        
        // Преобразование в Wei
        const totalSupplyWei = web3.utils.toWei(totalSupplyValue.toString(), 'ether');
        const maxOffersWei = web3.utils.toWei(maxOffersValue.toString(), 'ether');
        const maxRaisingWei = web3.utils.toWei(maxRaisingValue.toString(), 'ether');
        
        // 3. Получение начальной цены
        showStatusMessage('Расчет начальной цены...', 'info');
        const initialPrice = await calculateInitialPrice(
            maxRaisingValue,
            totalSupplyValue,
            maxOffersValue
        );
        
        // 4. Подготовка данных для создания токена
        const tokenData = {
            creator: account,
            name: tokenNameInput.value.trim(),
            symbol: tokenSymbolInput.value.trim(),
            totalSupply: totalSupplyWei,
            maxOffers: maxOffersWei,
            maxRaising: maxRaisingWei,
            imageUrl: imageUrl,
            // Дополнительные данные, которые будут сохранены в метаданных
            description: tokenDescriptionInput.value.trim(),
            raisedToken: selectedToken,
            tag: selectedTag,
            website: websiteInput.value.trim(),
            twitter: twitterInput.value.trim(),
            telegram: telegramInput.value.trim()
        };
        
        // 5. Получение подписи для создания токена
        showStatusMessage('Получение подписи...', 'info');
        const signatureData = await getTokenCreationSignature(tokenData);
        
        // 6. Создание токена через TokenManager2
        showStatusMessage('Отправка транзакции...', 'info');
        
        // Инициализация контракта TokenManager2
        const tokenManager2Contract = new web3.eth.Contract(
            tokenManager2ABI,
            TOKEN_MANAGER2_ADDRESS
        );
        
        // Получение размера комиссии за создание токена из контракта
        const launchFee = await tokenManager2Contract.methods._launchFee().call();
        
        // Создание токена
        const tx = await tokenManager2Contract.methods.createToken(
            signatureData.data,
            signatureData.signature
        ).send({
            from: account,
            value: launchFee,
            gas: 5000000 // Примерное количество газа
        });
        
        console.log('Транзакция успешно отправлена:', tx);
        
        // Поиск события создания токена
        const tokenCreateEvent = tx.events.TokenCreate;
        if (tokenCreateEvent) {
            const newTokenAddress = tokenCreateEvent.returnValues.token;
            showStatusMessage(`Токен успешно создан! Адрес: ${newTokenAddress}`, 'success');
            
            // Можно добавить кнопку для просмотра токена на BscScan
            const bscScanLink = `https://bscscan.com/token/${newTokenAddress}`;
            // ... добавление ссылки на страницу ...
        } else {
            showStatusMessage('Токен создан, но не удалось получить адрес.', 'success');
        }
    } catch (error) {
        console.error('Ошибка при создании токена:', error);
        showStatusMessage('Ошибка при создании токена: ' + error.message, 'error');
    } finally {
        // Сбросить состояние кнопки
        createTokenBtn.disabled = false;
        submitSpinner.style.display = 'none';
        createTokenBtn.textContent = 'Подключить кошелек и создать токен';
    }
}

// Функция для быстрой проверки статуса бэкенда
async function checkBackendStatus() {
    try {
        const response = await fetch(`${API_BASE_URL}/status`);
        if (response.ok) {
            const data = await response.json();
            console.log('Статус бэкенда:', data);
            return true;
        } else {
            console.error('Бэкенд недоступен');
            return false;
        }
    } catch (error) {
        console.error('Ошибка при проверке статуса бэкенда:', error);
        return false;
    }
}

// Функция для обновления URL API после запуска ngrok
function updateApiUrl(newUrl) {
    if (newUrl) {
        window.API_BASE_URL = newUrl;
        console.log('API URL обновлен:', newUrl);
        
        // Проверка подключения к новому URL
        checkBackendStatus()
            .then(isAvailable => {
                if (isAvailable) {
                    showStatusMessage('Подключение к бэкенду установлено', 'success');
                } else {
                    showStatusMessage('Не удалось подключиться к бэкенду', 'error');
                }
            });
    }
}

// Добавление поля для ввода URL ngrok
function addNgrokUrlInput() {
    const container = document.querySelector('.container');
    const formSection = document.createElement('div');
    formSection.className = 'form-section';
    formSection.style.marginTop = '20px';
    
    formSection.innerHTML = `
        <div class="form-group">
            <label for="ngrokUrl">Ngrok URL</label>
            <div style="display: flex;">
                <input type="text" id="ngrokUrl" placeholder="https://your-ngrok-url.ngrok.io" style="flex: 1; margin-right: 10px;">
                <button id="updateNgrokUrl" class="btn btn-primary" style="width: auto;">Обновить</button>
            </div>
            <p style="margin-top: 5px; font-size: 0.8rem; color: #aaa;">
                Введите URL ngrok для подключения к бэкенду
            </p>
        </div>
    `;
    
    container.appendChild(formSection);
    
    document.getElementById('updateNgrokUrl').addEventListener('click', () => {
        const ngrokUrl = document.getElementById('ngrokUrl').value.trim();
        if (ngrokUrl) {
            updateApiUrl(ngrokUrl + '/api');
        } else {
            showStatusMessage('Пожалуйста, введите URL ngrok', 'error');
        }
    });
}

// Добавление поля ngrok при инициализации
document.addEventListener('DOMContentLoaded', () => {
    // Проверить, доступен ли бэкенд по умолчанию
    checkBackendStatus()
        .then(isAvailable => {
            if (!isAvailable) {
                // Если бэкенд недоступен по умолчанию, добавить поле для ввода URL ngrok
                addNgrokUrlInput();
            }
        });
});
